# pyflaker `0.0.0`
`pyflaker` is a pure Python snowflake ID generator. It offers a standalone `pyflake_generator` function that can be used to create unique snowflake IDs, as well as an optional `PyflakeClient` class to easily manage a generator and generate IDs on the fly.

# Support
Discord - `Drix#8355`

# Features
- `Pyflake` - A deconstructed ID class, detailing the `pid`, `seed`, `sequence`, and `epoch` used to create the `64 bit` `snowflake` ID.
- `generate_seed` - A function that returns a random `int` value that is no greater in length than a provided `bits` size
- `pyflake_generator` - Standalone function that outputs a `generator` producing 64-bit snowflake IDs.
- `PyflakeClient` - A simple client class to handle the creation and management of a single `pyflake_generator` instance, and convenient ID generation and translation

# Requirements
- Python 3.10

## Core modules imported
- `time` - Used to generate timestamp values
- `random` - Used to generate seed values within `generate_seed`

# Usage
## generate_seed(`bits: int`)
This package includes a handy function for quick seed generation, which outputs a random number no longer than the provided bit value.

To generate a seed with a bit value of no more than 5, as is the case with both the `pid` and `seed` variables, call the `generate_seed(bits)` function and store the response for later use.

Both the `PyflakeClient` class and `pyflake_generator` function require `epoch` time, `pid` or process ID, and `seed` values on initialization. While the `pid` and `seed` variables are limited to a maximum integer value of `31`, or a bit length of `5` or `(2^5-1)`, the actual provided values of each are arbitrary. The `generate_seed` function makes generating these values a simple process.

Timestamp values are expected to be received as millisecond values no greater than `42` bits in length that may be converted to a human-readable date. While a valid <42-bit integer may be generated using the `generate_seed` function, timestamp values should NOT be generated using the `generate_seed` function if a human-readable date is expected to be referenced from the ID in the future.
```python
  from pyflaker import generate_seed
  
  seed = generate_seed(5)
  print(seed)
```
## Pyflake(`epoch: int`, `timestamp: int`, `pid: int`, `seed: int`, `sequence: int`)
This package includes a class instance that allows for easy reference to the attributes used to construct a `64 bit` `snowflake`.

When used in conjunction with the `pyflake_generator` function, or `PyflakeClient` class, `snowflake` IDs can quickly be generated for almost any use-case where a unique (long) integer ID is required, and tying it back to a timestamp, or date of record creation, may be useful.

```python
  from time import time
  from pyflaker import generate_seed, Pyflake

  # Sun, 15 Apr 2019 04:12:00.000-GMT+0:00
  epoch = 1555301520000

  pid = generate_seed(5)
  seed = generate_seed(5)
  timestamp = int(time() * 1000)  
  sequence = generate_seed(12)

  snowflake = Pyflake(epoch, timestamp, pid, seed, sequence)
  # the `64-bit` snowflake `int` ID generated by the class instance
  print(snowflake.snowflake())
  
  # the `42-bit` timestamp value used to generate this `snowflake`
  print(snowflake.timestamp)
```
## pyflake_generator(`epoch: int`, `pid: int`, `seed: int`, `sequence_bits: int`, `sleep: int = x / 1000`)
A standalone snowflake ID generator may be created without an overhead `PyflakeClient` by importing and calling the `pyflake_generator()` function.

While made available, the `sleep` parameter is optional, and will define how long the generator should wait if it encounters a situation where its ID sequence becomes overrun, or other time-related issues where the generator may need to pause before returning a value to the requesting client. Passing a value of `1` will instruct the function to delay for `1 millisecond` before proceeding, which is sufficient for this generator's purposes.

A `12 bit` sequence has a shelf life of no longer than `1 millisecond`, mitigating a very small, although still realistic chance, that two IDs will be generated at once. Delaying the client by a minimum of `1 millisecond` ensures overrun sequences do not occur, and IDs remain unique for the life of the generator.
```python
  from pyflaker import pyflake_generator, generate_seed

  epoch = 1555301520000

  pid = generate_seed(5) # 5 bits, random.randint(1, 31) or random.randint(1, (2^5-1))
  seed = generate_seed(5) # 5 bits, random.randint(1, 31) or random.randint(1, (2^5-1))
  sequence_bits = 12 # maximum bit length of the sequence
  sleep = 1 # 1 / 1000 = 1 ms (one millisecond)

  generator = pyflake_generator(epoch, pid, seed, sequence_bits, sleep)
```

To generate an ID from `pyflake_generator`, the `next(<pyflake_generator>)` method should be called, and the resulting value stored for later reference:
```python
  id = next(generator)
  print(id)
```
Expected output is a `Pyflake` object with the following attributes:
```python
  {
    'epoch': int,
    'timestamp': int,
    'seed': int,
    'pid': int,
    'sequence': int
  }
```
`Pyflake` instances also have the following methods:
- `snowflake()` - returns `int`
- `timestamp_bits()` - returns `int`
- `pid_bits()` - returns `int`
- `seed_bits()` - returns `int`
- `sequence_bits()` - returns `int`
- `timestamp_shift()` - returns `int`
- `pid_shift()` - returns `int`
- `seed_shift()` - returns `int`
 
## PyflakeClient(`epoch: int`)
This package offers the `PyflakeClient` class to easily create, renew, and destroy a `pyflake_generator`, as well as generate IDs with a cleaner API versus calling `next(<pyflake_generator>)`.
```python
  from pyflaker import PyflakeClient, generate_seed

  epoch = 1555301520000

  client = PyflakeClient(epoch)    
```
Once a client instance has been created, a generator can be created for it by calling the `PyflakeClient.create_generator(pid, seed)` method.
```python
  pid = generate_seed(5)
  seed = generate_seed(5)  

  client.create_generator(pid, seed)
```
The `PyflakeClient`'s `_generator` attribute, storing the result of the `pyflake_generator` produced on initial generator creation, may be manually destroyed at any time by calling the `PyflakeClient.destroy_generator()` method.
```python
  client.destroy_generator()
```
The `PyflakeClient` also offers the ability to renew the available `pyflake_generator` by calling the `PyflakeClient.renew_generator(pid, seed)` method.
```python
  client.renew_generator(pid, seed)
```
Once the available `pyflake_generator` has been renewed, new IDs may be perpetually generated from the new `pyflake_generator` until the script is terminated, or the client's `_generator` attribute is renewed again or destroyed.

To generate an ID from the `PyflakeClient` module, the `PyflakeClient.generate()` method should be called, and the resulting value stored for later reference:
```python
  id = client.generate()
  print(id)
```
Expected output when requesting a snowflake ID from the `PyflakeClient` is a `Pyflake` instance.

The `PyflakeClient` class offers a `_cache` attribute, which stores a record of all `Pyflake` instances generated for the life of the `PyflakeClient`. Entries here are stored within a `dict` and keyed by value returned by the `Pyflake.snowflake()` method at the time of caching.

General `PyflakeClient` metadata is available by calling the `get_info()` method, which returns a `dict` object with the following entries:
```python
  {
    'epoch': int, # represents the epoch time (in milliseconds) which all client snowflake IDs are based
    'pid': int, # represents the 'process id' specified by the managing client
    'seed': int, # represents the 'seed' value specified by the managing client
    'generated': int, # represents the number of snowflakes generated since client initialization
    'generator': bool # indicates the presence of an available client generator
  }
```
At times it may be convenient to convert a `64-bit` snowflake `int` value and convert it back to the timestamp used to generate it. Conversion back to a timestamp will always be possible so long as the ID's `epoch` time is known. Having access to the snowflake in `Pyflake` form is convenient, but not always practical, so conversion back to a timestamp via the `int` form of the snowflake is made available via the `PyflakeClient.timestamp()` method.

```python
  fmt = 'ms' # `ms` for `milliseconds` or `s` for `seconds`, optional
  
  timestamp = client.timestamp(id.snowflake, fmt)
  print(timestamp)
```
