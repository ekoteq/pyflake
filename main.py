import time
import math
import random

# returns a random integer that is no less than one, and no greater
# than the maximum integer value of the bits provided
def generate_seed(bits):
    return random.randint(1, (2^bits-1))

class Snowflake():
    def __init__(self, epoch, pid, seed, sequence, snowflake):
        self.epoch = epoch
        self.pid = pid
        self.seed = seed
        self.sequence = sequence
        self.snowflake = snowflake

    def string(self):
        return f'{self.snowflake}'

    # all generated IDs may be converted back into a timestamp by stripping
    # the lower 22 bits and adding the epoch time into the remaining value.
    # A timestamp cannot be returned without knowing the epoch used to
    # generate it.
    def timestamp(self, fmt = 'ms'):
        # strip the lower 22 bits holding the pid, seed, and sequence
        timestamp = self.snowflake >> 22
        # adjust for defined epoch time (ms)
        timestamp += self.epoch

        # clients can optionally request timestamp in seconds format
        # by specifying fmt as 's' instead of 'ms'
        # this may return a float value
        if fmt == 's':
            timestamp = timestamp / 1000

        return timestamp

# returns a pyflake_generator that allows a client to generate IDs by calling
# `next(<pyflake_generator>)` on the generator
def pyflake_generator(epoch, pid, seed, sleep = lambda x: time.sleep(x / 1000)):
    # A snowflake is comprised of 64 total bits
    # 42 of the 64 bits exist in the timestamp value (in milliseconds)
    # 22 of the 64 total bits exist in:
    pid_bits = 5
    seed_bits = 5
    sequence_bits = 12

    # define the maximum allowed seed values based on defined bits
    max_pid = -1 ^ (-1 << pid_bits)
    max_seed = -1 ^ (-1 << seed_bits)
    sequence_mask = -1 ^ (-1 << sequence_bits)

    # bit position where the process ID can be found in the snowflake
    pid_shift = sequence_bits

    # bit position where the seed value can be found in the snowflake
    seed_shift = sequence_bits + pid_bits

    # left-hand bit position where the timestamp can be found
    timestamp_shift = sequence_bits + pid_bits + seed_bits

    # enforce maximum integers allowed on provided seed values
    assert pid >= 0 and pid <= max_pid
    assert seed >= 0 and seed <= max_seed

    # if all is well, pyflake_generator creation begins

    # local pyflake_generator variables
    last_timestamp = -1
    sequence = 0

    # this process will loop 'while true' until a yield statement is
    # reached, at which time the loop will be paused pending a call to
    # `next(<generator>)`, which will return a string value and increment
    # the sequence. Multiple unique IDs may be crafted from a single
    # pyflake_generator instance, and near-infinite unique IDs may be
    # generated by utilizing multiple pyflake_generator instances
    while True:
        timestamp = math.floor(time.time() * 1000)

        # If the previous timestamp is greater than the current timestamp,
        # as if time is moving backwards, wait until time catches up to
        # ensure only sequential IDs are issued in ascending order
        if last_timestamp > timestamp:
            sleep(last_timestamp-timestamp)
            continue

        # if an ID was already generated under the current sequence value
        # as such may be the case in race conditions, where multiple IDs
        # are requested at the same time, we want to increase the sequence
        # before proceeding.
        if last_timestamp == timestamp:
            sequence = (sequence + 1) & sequence_mask
            # in the event the sequence becomes overrun, the sequence is updated
            # and the process continues after a one millisecond delay, ensuring a new
            # timestamp is used, preventing conflicts in IDs where sequences are
            # full, or cannot provide further unique values
            if sequence == 0:
                sequence = -1 & sequence_mask
                sleep(1)
                continue
        # Otherwise, if the current timestamp is greater than the
        # previous timestamp, the sequence is reset, as there will be no
        # conflicts with previous IDs under a new timestamp
        else:
            sequence = 0

        # update the 'last_timestamp' value with the most-recently obtained
        # timestamp, used to generate the currently-requested snowflake
        last_timestamp = timestamp

        # yield the loop and return the value to the requesting client
        # pending future client requests
        yield Snowflake(
            epoch = epoch,
            pid = pid,
            seed = seed,
            sequence = sequence,
            snowflake = (
                # subtract the current timestamp from the defined epoch, which
                # returns the miliseconds passed since the epoch time, and define
                # the timestamp value in the sequence relative to the defined
                # 'timestamp_shift' bit value defined above
                ((timestamp-epoch) << timestamp_shift) |
                # the same is done to the seed and pid values for sequence placement
                (seed << seed_shift) |
                (pid << pid_shift) |
                # finally, the current sequence value is returned, preventing race
                # conditions and ensuring uniqueness across IDs generated within
                # the same millisecond
                sequence
            )
        )

# a snowflake pyflake_generator client class
# use of this class is not required - a pyflake_generator may be created by
# calling the global `pyflake_generator` function above
# the below class just makes managing the generator that much easier
class PyflakeClient():
    def __init__(self, epoch):
        # the client relies on this to translate snowflake IDs back into
        # timestamps - changing this value will not affect the available
        # generator, but will affect the client's ability to translate
        # previously generated snowflakes back into timestamp values
        self._epoch = epoch
        # general information - how many snowflakes have been generated
        # since client initialization, indiscriminate of generator renewals
        self._generated = 0
        # a cache of snowflakes generated since initialization
        self._cache = dict()

    # general information about the client instance
    def get_info(self):
        res = {
            'pid': getattr(self, 'pid', None),
            'seed': getattr(self, 'seed', None),
            'epoch': self._epoch,
            'generated': self._generated,
        }
        # checks if the client has a generator available
        # and adds the relevant status to the response
        if getattr(self, 'generator', None):
            res['generator'] = True
        else:
            res['generator'] = False

        return res

    # destroys the current pyflake_generator, if one exists
    def destroy_generator(self):
        # we only delete the attribute if it exists
        if getattr(self, 'generator', None):
            delattr(self, 'pid')
            delattr(self, 'seed')
            delattr(self, 'generator')

    # creates a new pyflake_generator, if one does not exist
    def create_generator(self, pid, seed):
        # requesting clients will need to ensure existing generators are destroyed
        # before trying to create a new one

        # if the requesting client needs more than one generator, more than one
        # client instance should be created, since snowflakes are unique to the
        # pid and seed used to generate them, and especially unique to the client's
        # epoch timestamp.
        if not getattr(self, 'generator', None):
            # changing the values of these attributes will not affect the generator
            # so there's no need to discourage clients from changing their values
            setattr(self, 'pid', pid)
            setattr(self, 'seed', seed)

            # the generator can be re-constructed via the `create_generator` method
            # and it's up to the requesting client to manage its creation or destruction
            # so there's no need to discourage modifying the attribute
            setattr(self, 'generator', pyflake_generator(self._epoch, pid, seed))

    # replaces the current pyflake_generator with a new one, and allows
    # the requesting client to define a process ID and seed value
    def renew_generator(self, pid, seed):
        self.destroy_generator()
        self.create_generator(pid, seed)

    # shortcut function, quickly returns a snowflake ID from the attached
    # pyflake_generator, based on timestamp value at the time the request
    # was made
    def generate(self):
        # a deconstructed snowflake reference object
        # direct access to the snowflake ID is available via `res.get('snowflake')`

        # store a record of the index we're going to use for this entry in the cache
        # since we're going to reference it more than once
        cache_idx = self._generated + 1

        # increase the number of generated records
        self._generated += 1

        # grab the deconstructed response from the generator
        res = next(self.generator)
        # add the cache index to the deconstructed response
        res['idx'] = cache_idx

        # add the entry to the cache
        self._cache[cache_idx] = res

        # finally, return the class object requesting client
        # calling res.string will return a string formatted
        # snowflake, while res.snowflake will return a long int
        return res
